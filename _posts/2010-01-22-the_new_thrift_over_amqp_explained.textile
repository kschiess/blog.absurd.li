---
title: "The new Thrift / AMQP bridge: Explained"
tags: 
  - thrift
  - amqp
  - ruby
  - toamqp
  - rpc
  - thrift_over_amqp
---

IDEA: Include rake task and threaded client into toamqp
TODO: link up thrift

I have reworked the <code>thrift_over_amqp</code> plugin into a real gem that
can be used everywhere. To do this, I've rewritten the code and cleaned up the
javaish API mess. Must've been the contact stress with thrift APIs. But this
is "old news":/2010/01/04/redesign_and_rename.html already.

Let me try to give you some new .. well ah .. news. Here's a graphic list of 
operation modes for thrift calls when sent via an AMQP broker: 

IMAGE: 
Client to one
Client to one out of many
Client to many

Thrift itself provides you just with the same old point to point procedure
call (A). Where do the other combinations come from?, you ask. Those are 
pretty much what AMQP does for you. Using toamqp, you can take advantage of
these other operation modes for RPC calls as well. 

To say it with the words of the king â€“ A little less conversation, a little
more action please: 

h2. One to One example

About the simplest thing you can do with <code>toamqp</code> is to connect
two points of your infrastructure via RPC. To do this, you need to write a 
thrift specification of the receiver: 

<pre><code class="sh_thrift">
  service receiver {
    /**
     * Let's say we have a search server somewhere, answering with a list
     * of search results to us:
     */
     list<string> search(1: string word)
  }
</code></pre>

This is better than the usual <code>getTime</code> RPC call, since we '_now
what time it is_', right? As you can see, thrift has a rich set of types that
can be sent over the wire. You can create new types yourself and even do 
exception handling. 

You may be wondering what the '<code>1: </code>' is about in the list of 
arguments of our function. That is thrift's micro-level versioning. You give
all your parameters a unique id and have to make sure you only use that id
when you're talking about the exact same thing. I can rename word, as long as
I use the same id; I can also introduce new parameters unilaterally and be 
assured that only receivers who have use for them will receive them. 

h3. Turning the specification in some code

You can now use thrift to generate Ruby code from that. This generally looks
like this: 

<pre><code class="sh_bash">
  > thrift --gen rb receiver.thrift
</code></pre>

This only works if you install the whole thrift(LINK) suite, not just the
rubygem. Doing so will give you the compiler for the thrift IDL. I may someday
include a new rake task generator into toamqp for making this step real easy.
For now you are stuck with the command line.

You most likely get a '<code>gen-rb</code>' subdirectory that contains three
ruby files. We're now just one step away from writing our sender/receiver
pair. For the request sender (aka client), we write: 

<pre><code class="sh_ruby">
  require 'toamqp'    # requires thrift and bunny
  require 'gen-rb/receiver.rb'

  sender = TOAMQP.client('receiver', Receiver)
</code></pre>

The first argument to <code>.client</code> is the name of the exchange that 
you want to use for all messages. Sender and receiver must use the same name
here. Think of it as the _address_ of the receiver. 

The second argument is the module that contains all thrift generated classes.
TOAMQP will dynamically look up the '<code>client</code>' class from that 
module and return you an instance of that client, connected to your queue
server. Speaking of which: You can configure the connection attributes using
the longish method <code>#connection_attributes=</code> on the connection 
manager: 

<pre><code class="sh_ruby">
  TOAMQP.connection_manager.connection_attributes = {
    :user => 'username', 
    :password => 'password', 
    :host => 'myqueue.mydomain.com'
  }
</code></pre>

The default is a connect to localhost.

h3. Server implementation 

Thrift makes it easy to write a receiver for our service (a simple one at
least):

<pre class="sh_ruby"><code>
  require 'toamqp'
  require 'gen-rb/receiver.rb'
  
  class ReceiverHandler < TOAMQP::Service::Base
    exchange 'receiver'   # same as we used above
    serves Receiver
    
    def search
      # search implementation with proper exception handling
      return %w{a few search results}
    end
  end
  
  TOAMQP.server(ReceiverHandler.new).serve
</code></pre>

This will create thrift server instance and call its <code>#serve</code> method that will singlethreadedly (is that a word?) serve requests from the
sender. So doing 

<pre class="sh_ruby"><code>
  sender.search('chunky bacon')
</code></pre>

will return .. no chunky bacon anymore(LINK), think about the serialization
issues, but a ruby array of your search results. This is all thanks to thrift
- all that toamqp does at this point is connect the thrift endpoints through
your message queue.

I have chosen to make the handler implementation lean towards ActiveRecord-style class declarations. This has some disadvantages: You really
have to decide what you're going to serve and how the exchange is going to be
named. But I think the readability makes up for that. 

Note that there is a second argument to <code>#server</code> that allows you
to specify which server class to instanciate. There is no reason why a
multithreaded or an evented server implementation should not work as well,
although I must admit that my tests are cruelly lacking in that area. Speaking
of tests: toamqp also comes with a server called
'<code>TOAMQP::SpecServer</code>' that can help you write integration tests
against the whole infrastructure.

h2. Extending to round robin load balancing

This is all very plain thrift stuff - nothing you could not achieve with tcp 
transports as well. Let's take advantage of your message broker (your queue) 
a little more. One of the things that a broker does as per specification is 
round-robin balancing of message receivers. 

If we connect more than one receivers to the exact same exchange (a
simplification of issues here, more down below), they will each get 50% of the
load. It's really as simple as that, just run two servers. And nothing
stops you from running 10, on different machines. Let me give you a small 
example of a forking server that starts more than one server process on 
one machine: 

<pre class="sh_ruby"><code>
  $pids = []
  2.times do 
    $pids << fork { TOAMQP.server(ReceiverHandler.new).serve }
  end
  
  Signal.trap("CHLD") {
    Process.wait; 
    $pids.delete($?.pid)
  }
  
  sleep 1 until $pids.empty?
</code></pre>

Of course, this is a brutal oversimplification of the issues involved(LINK to
self). You might want to look at the threaded server that comes with thrift or/and at unicorn(LINK), a forking web server for more information about 
this. Let me just say that more often than not, the simple line given 
above that starts a simple server is really enough. 

h2. Routing messages to the right server

h2. Broadcasting to many servers

