---
title: "The new Thrift / AMQP bridge: Explained"
tags: 
  - thrift
  - amqp
  - ruby
  - toamqp
  - rpc
  - thrift_over_amqp
---

IDEA: Include rake task and threaded client into toamqp
TODO: link up thrift http://incubator.apache.org/thrift/
TODO: Update thrift, retest toamqp

I have reworked the <code>thrift_over_amqp</code> plugin into a real gem that
can be used everywhere. To do this, I've rewritten the code and cleaned up the
javaish API mess. Must've been the contact stress with thrift APIs. But this
is "old news":/2010/01/04/redesign_and_rename.html already.

Let me try to give you some new .. well ah .. news. Here's a graphic list of 
operation modes for thrift calls when sent via an AMQP broker: 

IMAGE: 
Client to one
Client to one out of many
Client to many

Thrift itself provides you just with the same old point to point procedure
call (A). Where do the other combinations come from?, you ask. Those are 
pretty much what AMQP does for you. Using toamqp, you can take advantage of
these other operation modes for RPC calls as well. 

To say it with the words of the king â€“ A little less conversation, a little
more action please: 

h2. One to One example

About the simplest thing you can do with <code>toamqp</code> is to connect
two points of your infrastructure via RPC. To do this, you need to write a 
thrift specification of the receiver: 

<pre class="sh_thrift"><code>
  service receiver {
    /**
     * Let's say we have a search server somewhere, answering with a list
     * of search results to us:
     */
     list<string> search(1: string word)
  }
</code></pre>

This is better than the usual <code>getTime</code> RPC call, since we '_now
what time it is_', right? As you can see, thrift has a rich set of types that
can be sent over the wire. You can create new types yourself and even do 
exception handling. 

You may be wondering what the '<code>1: </code>' is about in the list of 
arguments of our function. That is thrift's micro-level versioning. You give
all your parameters a unique id and have to make sure you only use that id
when you're talking about the exact same thing. I can rename word, as long as
I use the same id; I can also introduce new parameters unilaterally and be 
assured that only receivers who have use for them will receive them. 

h3. Turning the specification in some code

You can now use thrift to generate Ruby code from that. This generally looks
like this: 

<pre class="sh_bash"><code>
  > thrift --gen rb receiver.thrift
</code></pre>

This only works if you install the whole thrift(LINK) suite, not just the
rubygem. Doing so will give you the compiler for the thrift IDL. I may someday
include a new rake task generator into toamqp for making this step real easy.
For now you are stuck with the command line.

You most likely get a '<code>gen-rb</code>' subdirectory that contains three
ruby files. We're now just one step away from writing our sender/receiver
pair. For the request sender (aka client), we write: 

<pre class="sh_ruby"><code>
  require 'toamqp'    # requires thrift and bunny
  require 'gen-rb/receiver.rb'

  sender = TOAMQP.client('receiver', Receiver)
</code></pre>

The first argument to <code>.client</code> is the name of the exchange that 
you want to use for all messages. Sender and receiver must use the same name
here. Think of it as the _address_ of the receiver. 

The second argument is the module that contains all thrift generated classes.
TOAMQP will dynamically look up the '<code>client</code>' class from that 
module and return you an instance of that client, connected to your queue
server. Speaking of which: You can configure the connection attributes using
the longish method <code>#connection_attributes=</code> on the connection 
manager: 

<pre class="sh_ruby"><code>
  TOAMQP.connection_manager.connection_attributes = {
    :user => 'username', 
    :password => 'password', 
    :host => 'myqueue.mydomain.com'
  }
</code></pre>

The default is a connect to localhost.

h3. Server implementation 

Thrift makes it easy to write a receiver for our service (a simple one at
least):

<pre class="sh_ruby"><code>
  require 'toamqp'
  require 'gen-rb/receiver.rb'
  
  class ReceiverHandler < TOAMQP::Service::Base
    exchange 'receiver'   # same as we used above
    serves Receiver
    
    def search
      # search implementation with proper exception handling
      return %w{a few search results}
    end
  end
  
  TOAMQP.server(ReceiverHandler.new).serve
</code></pre>

This will create thrift server instance and call its <code>#serve</code> method that will singlethreadedly (is that a word?) serve requests from the
sender. So doing 

<pre class="sh_ruby"><code>
  sender.search('chunky bacon')
</code></pre>

will return .. no chunky bacon anymore(LINK), think about the serialization
issues, but a ruby array of your search results. This is all thanks to thrift
- all that toamqp does at this point is connect the thrift endpoints through
your message queue.

I have chosen to make the handler implementation lean towards ActiveRecord-style class declarations. This has some disadvantages: You really
have to decide what you're going to serve and how the exchange is going to be
named. But I think the readability makes up for that. 

Note that there is a second argument to <code>#server</code> that allows you
to specify which server class to instanciate. There is no reason why a
multithreaded or an evented server implementation should not work as well,
although I must admit that my tests are cruelly lacking in that area. Speaking
of tests: toamqp also comes with a server called
'<code>TOAMQP::SpecServer</code>' that can help you write integration tests
against the whole infrastructure.

h2. Extending to round robin load balancing

This is all very plain thrift stuff - nothing you could not achieve with tcp 
transports as well. Let's take advantage of your message broker (your queue) 
a little more. One of the things that a broker does as per specification is 
round-robin balancing of message receivers. 

If we connect more than one receivers to the exact same exchange (a
simplification of issues here, more down below), they will each get 50% of the
load. It's really as simple as that, just run two servers. And nothing
stops you from running 10, on different machines. Let me give you a small 
example of a forking server that starts more than one server process on 
one machine: 

<pre class="sh_ruby"><code>
  $pids = []
  2.times do 
    $pids << fork { TOAMQP.server(ReceiverHandler.new).serve }
  end
  
  Signal.trap("CHLD") {
    Process.wait; 
    $pids.delete($?.pid)
  }
  
  sleep 1 until $pids.empty?
</code></pre>

Of course, this is a brutal oversimplification of the issues involved(LINK to
self). You might want to look at the threaded server that comes with thrift or/and at unicorn(LINK), a forking web server for more information about 
this. 

One small warning at this point: Thrift itself is not thread safe, and neither
is toamqp. You cannot just spawn a few Ruby threads and use the client in all
of them; you might have to create one client object per thread. And you should
really look at the servers that come with thrift, they solve many of the
issues with threading you might have. 

So road-robin balancing and load distribution over several machines is done, 
what is next? 

h2. Routing messages to the right server

Sometimes you don't just have many servers of the _same kind_, but many
servers with the same interface of _different kind_. toamqp supports this
directly.

Let's say you have two places to search for, your desk and your wastebasket. (Since we all know that important documents are stored there, right?) So ideally, you would want to search them both: 

<pre class="sh_ruby"><code>
  desk = TOAMQP.client('receiver', Receiver, { :location => :desk })
  wastebasket = TOAMQP.client('receiver', Receiver, { :location => :wastebasket })
  
  [desk, wastebasket].map { |sender| sender.search('important document') }
</code></pre>

This will fail brutally after experimenting with the code above. The reason is
that for this to work, you will need to redeclare the 'receiver' exchange on
your broker to be of a different type. Before, it was _direct_ (as in send my
messages _directly_ to the receiver), now it should be _headers_ (as in:
_filter by the headers_ I send). Luckily toamqp does this for you, provided
you clear the old variant from your servers first. You can either do this by
restarting your server or by manually issuing a delete call via 'bunny'.

For really easy experimentation you should just change the exchange name to 
'receiver_filtered'. This way toamqp will declare a new exchange and your 
AMQP broker will not throw an error. 

I'll just show you how to implement a wastebasket receiver; the desk receiver
should follow from that. Note that since they implement the _same_ interface 
but have _different implementations, you will really need two different classes: 

<pre class="sh_ruby"><code>
  class Wastebasket < TOAMQP::Service::Base
    exchange 'receiver', match => { :location => :wastebasket }
    serves Receiver
    
    def search(query)
      # ...
    end
  end
</code></pre>

h3. Combining the layouts

These two layouts (Round-Robin Load Balancing and Header Routing) can of
course be combined. Together these two will help with most if not all
communication needs you might have. 

h2. Broadcasting to many receivers

You can also send out a message to many receivers. The only limitation here
is that you cannot get results from more that one receiver, since thrift
doesn't provide that. But it provides you with the <code>async</code> keyword
that allows you to send out messages without listening for the answer, exactly
what we need for this broadcast-enabled service: 

<pre class="sh_thrift"><code>
  service Broadcast {
    async void hi(1: string ipAddress)
  }
</code></pre>

And here's a handler class to match this service: 

<pre class="sh_ruby"><code>
  class Registry < TOAMQP::Service::Base
    exchange 'broadcast', :broadcast => true
    serves Broadcast
    
    def hi(ip_address)
      # remember the service that announces itself
    end
  end
</code></pre>

By now, you should know how the client for this is created, so I wont repeat
that here. Perhaps you've noted the inversion of the roles that governs this
example: a service provider would announce its presence to all interested 
service consumers using the above thrift interface. So here the server really
is the client. 

To clear this up, lets pseudocode a 

h2. Possible extensions, Status, Roadmap